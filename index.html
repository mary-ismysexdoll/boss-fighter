<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Crowd DPS — Boss Rush</title>
  <style>
    :root {
      --bg:#0b0f14; --panel:#121821; --muted:#8aa0b6; --text:#e9f0f8; --brand:#7cc3ff;
      --accent:#6bf1c8; --danger:#ff6b6b; --gold:#ffd166; --shadow:0 10px 30px rgba(0,0,0,.35);
      --radius:16px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans";
      color:var(--text);
      background:radial-gradient(1200px 800px at 20% -10%,#112131 0%,var(--bg) 60%),
                 radial-gradient(1000px 600px at 120% 10%,#182436 0%,transparent 60%),
                 var(--bg);
    }
    header{
      display:flex;align-items:center;justify-content:space-between;padding:18px 20px;gap:16px;
      position:sticky;top:0;backdrop-filter:blur(8px);
      background:linear-gradient(180deg,rgba(10,14,20,.85),rgba(10,14,20,.55));
      border-bottom:1px solid rgba(255,255,255,.06);z-index:5;
    }
    .title{font-weight:800;letter-spacing:.4px}.title span{opacity:.7;font-weight:600}
    .pill{display:inline-flex;align-items:center;gap:10px;background:#0f1722;border:1px solid rgba(255,255,255,.08);
      padding:10px 14px;border-radius:999px;box-shadow:var(--shadow);font-weight:600;color:var(--muted)}
    .pill .value{color:var(--text)}
    .btn{display:inline-flex;align-items:center;justify-content:center;padding:10px 14px;border:1px solid rgba(255,255,255,.1);
      border-radius:10px;background:linear-gradient(180deg,#1a2332,#121a26);color:var(--text);cursor:pointer;user-select:none;
      font-weight:700;box-shadow:var(--shadow);transition:transform .05s ease,filter .2s ease,background .2s ease}
    .btn.small{padding:8px 10px;font-size:12px}
    .btn:hover{filter:brightness(1.1)}
    .btn:active{transform:translateY(1px) scale(.99)}
    .btn.brand{background:linear-gradient(180deg,#2589ff,#1761c8);border-color:#2a66b8}
    .btn.neon{background:linear-gradient(180deg,#1f3b3b,#142626);border-color:#2e6f68;color:#b7fff0}
    main{display:grid;gap:18px;padding:18px;max-width:1400px;margin:0 auto;grid-template-columns:1fr minmax(420px,520px) 1fr}
    @media (max-width:1100px){main{grid-template-columns:1fr}.panel{order:unset!important}}
    .panel{background:linear-gradient(180deg,#0f1520,#0b1018);border:1px solid rgba(255,255,255,.07);
      border-radius:var(--radius);box-shadow:var(--shadow);padding:16px;min-height:120px}
    .panel h2{margin:0 0 10px;font-size:16px;font-weight:800;letter-spacing:.3px;color:var(--muted)}
    .cards{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px}
    .card{position:relative;overflow:hidden;border-radius:14px;background:linear-gradient(180deg,rgba(22,30,45,.9),rgba(16,20,30,.9));
      border:1px solid rgba(255,255,255,.05);box-shadow:0 8px 20px rgba(0,0,0,.25);padding:12px;display:grid;gap:10px}
    .card::before{content:"";position:absolute;inset:-2px;border-radius:16px;padding:1px;
      background:conic-gradient(from 180deg,rgba(124,195,255,.5),rgba(107,241,200,.45),rgba(255,209,102,.45),rgba(124,195,255,.5));
      -webkit-mask:linear-gradient(#000 0 0) content-box,linear-gradient(#000 0 0);
      -webkit-mask-composite:xor;mask-composite:exclude;pointer-events:none}
    .row{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .badge{font-size:11px;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);opacity:.9}
    .badge.tier{font-weight:800;letter-spacing:.4px}
    .name{font-weight:800;font-size:16px;letter-spacing:.2px}
    .stat{display:inline-flex;align-items:center;gap:8px;font-weight:700;color:var(--muted);padding:6px 8px;border-radius:8px;
      border:1px solid rgba(255,255,255,.08);background:#0e1520}
    .stat .v{color:var(--text)}
    .hpmini{height:10px;border-radius:999px;background:#0d1320;overflow:hidden;border:1px solid rgba(255,255,255,.08)}
    .hpmini>div{height:100%;background:linear-gradient(90deg,#34d399,#ffd166);width:100%}
    .ko{color:#ff9aa2;font-weight:800;letter-spacing:.3px}
    .toolbar{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
    .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .note{color:var(--muted);font-size:12px;margin-top:6px}
    .empty{color:var(--muted);text-align:center;padding:20px;border:1px dashed rgba(255,255,255,.12);border-radius:12px}
  </style>
</head>
<body>
  <header>
    <div class="title">Crowd DPS <span>· Boss Rush</span></div>
    <div class="toolbar">
      <div class="pill">Cash: <span class="value" id="cash">$0.00</span></div>
      <div class="pill">Boss Lvl: <span class="value" id="bossLevel">1</span></div>
      <div class="pill">Roll Cost: <span class="value" id="rollCost">$0.00</span></div>
      <button id="resetBtn" class="btn small" title="Reset local progress">Reset</button>
    </div>
  </header>

  <main>
    <section class="panel" id="allPlayersPanel" style="order:1">
      <h2>All Players (from Google Sheets)</h2>
      <div id="players" class="cards"></div>
      <div id="playersEmpty" class="empty" style="display:none">No players loaded yet.</div>
      <div class="note">
        Players sheet: headers A–G = F-Tier→SS-Tier, row 2+ = usernames. Stats sheet: same headers; row 2 = HP per tier; row 3 = DPS per tier.
      </div>
    </section>

    <section class="panel" id="bossPanel" style="order:0">
      <h2>Boss Arena</h2>
      <div class="boss">
        <div class="hero">
          <div class="row" style="justify-content:space-between;align-items:baseline">
            <div>
              <div class="name" style="font-size:20px;font-weight:900" id="bossName">—</div>
              <div class="muted" id="bossStats">HP — / —</div>
            </div>
            <div class="badge" id="bossBadge">Level 1</div>
          </div>
          <div class="hpmini" style="height:16px"><div id="hpFill" style="width:100%"></div></div>
          <div class="grid2">
            <div class="pill">Your DPS: <span class="value" id="yourDPS">0</span></div>
            <div class="pill">Your HP: <span class="value" id="yourHP">0</span></div>
          </div>
          <div class="toolbar">
            <button id="fightBtn" class="btn brand">Start Fight</button>
            <button id="newBossBtn" class="btn">New Boss</button>
            <button id="freeCardBtn" class="btn neon" title="First-time bonus: random F-Tier">Get Free Common Card</button>
            <button id="recruitBtn" class="btn" title="Roll a random card by rarity">Recruit (Roll)</button>
          </div>
          <div class="note" id="fightNote">Win to earn cash. Rewards grow slowly as bosses scale up.</div>
        </div>
      </div>
    </section>

    <section class="panel" id="teamPanel" style="order:2">
      <h2>Your Team</h2>
      <div id="team" class="cards"></div>
      <div id="teamEmpty" class="empty">You have no cards yet.</div>
    </section>
  </main>

  <script>
  // === CONFIG ===
  const SHEET_PLAYERS_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vQMUnfamouCORKPavgJqVoMsSNDyx-emsTNi5dJw2DNx1IcWnPH-I6tgeN9EsAWoLXCUSmWpe5JyfZn/pub?output=csv";
  const SHEET_STATS_URL   = "https://docs.google.com/spreadsheets/d/e/2PACX-1vRgc7Pm81icSxeJP3dySkafpNEyAElWNXiHUgue3wLcNUsanku5Q8NeigfuBA_BaYOokiKaltSe7g1z/pub?output=csv";

  const FALLBACK_STATS = {
    tiers: {
      "F-Tier": { hp: 120, dps: 6 },
      "D-Tier": { hp: 160, dps: 10 },
      "C-Tier": { hp: 210, dps: 16 },
      "B-Tier": { hp: 280, dps: 24 },
      "A-Tier": { hp: 360, dps: 36 },
      "S-Tier": { hp: 450, dps: 54 },
      "SS-Tier": { hp: 560, dps: 78 }
    }
  };

  const FALLBACK_PLAYERS = {
    "F-Tier": ["PixelPug", "Mossy", "LagBug"],
    "D-Tier": ["StormKid", "NanoFletch"],
    "C-Tier": ["EchoFox", "Starling"],
    "B-Tier": ["ArcDrifter"],
    "A-Tier": ["Aurora"],
    "S-Tier": ["Mythic"],
    "SS-Tier": ["Celestia"]
  };

  const TIER_ORDER = ["F-Tier","D-Tier","C-Tier","B-Tier","A-Tier","S-Tier","SS-Tier"];
  const TIER_COLORS = {
    "F-Tier":"#94a3b8",
    "D-Tier":"#a78bfa",
    "C-Tier":"#60a5fa",
    "B-Tier":"#34d399",
    "A-Tier":"#facc15",
    "S-Tier":"#fb7185",
    "SS-Tier":"#f97316"
  };
  const TIER_BASE_WEIGHTS = {"F-Tier":0.45,"D-Tier":0.20,"C-Tier":0.14,"B-Tier":0.09,"A-Tier":0.06,"S-Tier":0.04,"SS-Tier":0.02};
  const FAIRNESS = {
    cost: { base: 0.20, perRecruit: 0.02, dailyFree: 1, maxCost: 1.00 },
    pity: {
      A:  { softStart: 8,  softStep: 0.15, hard: 20 },
      S:  { softStart: 20, softStep: 0.20, hard: 45 },
      SS: { softStart: 40, softStep: 0.25, hard: 80 }
    }
  };

  // === UTIL ===
  const $ = (sel)=> document.querySelector(sel);
  const el = (tag, props={}, children=[])=>{
    const node=document.createElement(tag);
    Object.entries(props).forEach(([k,v])=>{
      if (k in node) node[k]=v; else node.setAttribute(k,v);
    });
    ([]).concat(children).filter(Boolean).forEach(child=> node.append(child));
    return node;
  };
  const clamp = (v,min,max)=> Math.min(max, Math.max(min,v));
  const pick = arr => arr[Math.floor(Math.random()*arr.length)];
  const rand = (a,b)=> a + Math.random()*(b-a);
  const fmtNum = n => Number(n||0).toLocaleString();
  const fmtCash = n => `$${Number(n||0).toFixed(2)}`;
  const idFrom = s => s.toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,'');
  const todayKey = ()=> new Date().toISOString().slice(0,10);

  // === STATE ===
  let tiers = {};
  let players = [];
  let collectionIds = [];
  let teamIds = [];
  let hpMap = {};
  let cash = 0;
  let bossLevel = 1;
  let boss = null;
  let pity = {A:0,S:0,SS:0};
  let recruitsToday = 0;
  let lastRecruitDay = '';
  let fighting = false;
  let fightTimer = null;

  // === PERSISTENCE ===
  function save(){
    localStorage.setItem('cdps.cash', String(cash));
    localStorage.setItem('cdps.bossLevel', String(bossLevel));
    localStorage.setItem('cdps.collection', JSON.stringify(collectionIds));
    localStorage.setItem('cdps.pity', JSON.stringify(pity));
    localStorage.setItem('cdps.recruitsToday', String(recruitsToday));
    localStorage.setItem('cdps.lastRecruitDay', lastRecruitDay || '');
    if (boss) localStorage.setItem('cdps.boss', JSON.stringify(boss));
  }
  function load(){
    cash = parseFloat(localStorage.getItem('cdps.cash')||'0')||0;
    bossLevel = parseInt(localStorage.getItem('cdps.bossLevel')||'1')||1;
    collectionIds = Array.from(new Set(JSON.parse(localStorage.getItem('cdps.collection')||'[]')));
    recruitsToday = parseInt(localStorage.getItem('cdps.recruitsToday')||'0')||0;
    lastRecruitDay = localStorage.getItem('cdps.lastRecruitDay')||'';
    try{ pity = JSON.parse(localStorage.getItem('cdps.pity')||'{"A":0,"S":0,"SS":0}'); }
    catch{ pity = {A:0,S:0,SS:0}; }
    try{ boss = JSON.parse(localStorage.getItem('cdps.boss')||'null'); }
    catch{ boss = null; }
  }

  // === FAIRNESS HELPERS ===
  function ensureDailyCounters(){
    const today = todayKey();
    if (lastRecruitDay !== today){
      lastRecruitDay = today;
      recruitsToday = 0;
      save();
    }
  }
  function totalRecruits(){ return collectionIds.length; }
  function currentRecruitCost(){
    ensureDailyCounters();
    const freeLeft = Math.max(0, FAIRNESS.cost.dailyFree - recruitsToday);
    if (freeLeft>0) return 0;
    const scaled = FAIRNESS.cost.base + FAIRNESS.cost.perRecruit * totalRecruits();
    return Math.min(FAIRNESS.cost.maxCost, Math.round(scaled*100)/100);
  }
  function updateRecruitCostUI(){
    const elCost = $('#rollCost');
    if (elCost) elCost.textContent = fmtCash(currentRecruitCost());
  }
  function dynamicTierWeights(){
    const weights = { ...TIER_BASE_WEIGHTS };
    const {A:PA,S:PS,SS:PSS} = FAIRNESS.pity;
    if (pity.A >= PA.softStart){
      const steps = pity.A - PA.softStart + 1;
      const mult = 1 + PA.softStep*steps;
      weights['A-Tier']*=mult; weights['S-Tier']*=mult; weights['SS-Tier']*=mult;
    }
    if (pity.S >= PS.softStart){
      const steps = pity.S - PS.softStart + 1;
      const mult = 1 + PS.softStep*steps;
      weights['S-Tier']*=mult; weights['SS-Tier']*=mult;
    }
    if (pity.SS >= PSS.softStart){
      const steps = pity.SS - PSS.softStart + 1;
      const mult = 1 + PSS.softStep*steps;
      weights['SS-Tier']*=mult;
    }
    return weights;
  }
  function pickTierWithPity(){
    const {A:PA,S:PS,SS:PSS} = FAIRNESS.pity;
    const available = tier => players.some(p=> p.tier===tier && !collectionIds.includes(p.id));
    if (pity.SS >= PSS.hard && available('SS-Tier')) return 'SS-Tier';
    if (pity.S >= PS.hard){
      const t = ['SS-Tier','S-Tier'].find(available);
      if (t) return t;
    }
    if (pity.A >= PA.hard){
      const t = ['SS-Tier','S-Tier','A-Tier'].find(available);
      if (t) return t;
    }
    const weights = dynamicTierWeights();
    const pool = Object.entries(weights)
      .filter(([tier,weight])=> weight>0 && available(tier));
    if (!pool.length) return null;
    const total = pool.reduce((sum,[,w])=> sum+w,0);
    let roll = Math.random()*total;
    for (const [tier, weight] of pool){
      roll -= weight;
      if (roll <= 0) return tier;
    }
    return pool[pool.length-1][0];
  }
  function bumpPity(tier){
    if (tier==='SS-Tier'){
      pity = {A:0,S:0,SS:0};
    } else if (tier==='S-Tier'){
      pity.S = 0;
      pity.A = 0;
      pity.SS += 1;
    } else if (tier==='A-Tier'){
      pity.A = 0;
      pity.S += 1;
      pity.SS += 1;
    } else {
      pity.A += 1;
      pity.S += 1;
      pity.SS += 1;
    }
  }

  // === DATA BUILDERS ===
  function parseCSV(text){
    if (!text) return [];
    const rows = [];
    let current = [];
    let value = '';
    let inQuotes = false;
    for (let i=0;i<text.length;i++){
      const ch = text[i];
      if (ch === '\r') continue;
      if (ch === '"'){
        if (inQuotes && text[i+1] === '"'){
          value += '"';
          i += 1;
        } else {
          inQuotes = !inQuotes;
        }
        continue;
      }
      if (ch === ',' && !inQuotes){
        current.push(value.trim());
        value = '';
        continue;
      }
      if (ch === '\n' && !inQuotes){
        current.push(value.trim());
        rows.push(current);
        current = [];
        value = '';
        continue;
      }
      value += ch;
    }
    if (value.length || current.length){
      current.push(value.trim());
    }
    if (current.length){
      rows.push(current);
    }
    return rows;
  }
  function mapHeaderToTiers(headers){
    const canonical = h =>{
      const k=(h||'').toString().toLowerCase().replace(/[^a-z]/g,'');
      if (k.includes('ftier')||k==='f') return 'F-Tier';
      if (k.includes('dtier')||k==='d') return 'D-Tier';
      if (k.includes('ctier')||k==='c') return 'C-Tier';
      if (k.includes('btier')||k==='b') return 'B-Tier';
      if (k.includes('atier')||k==='a') return 'A-Tier';
      if (k.includes('sstier')||k==='ss') return 'SS-Tier';
      if (k.includes('stier')||k==='s') return 'S-Tier';
      return null;
    };
    return headers.map(canonical);
  }
  function findHeaderRow(matrix){
    const maxScan = Math.min(5, matrix.length);
    let bestRow = 0;
    let bestHits = -1;
    for (let r=0;r<maxScan;r++){
      const hits = (matrix[r]||[]).map(h=> mapHeaderToTiers([h])[0]).filter(Boolean).length;
      if (hits>bestHits){ bestHits = hits; bestRow = r; }
    }
    return bestRow;
  }
  function createPlayerRecord(name, tier, hp, dps, usedIds){
    const base = idFrom(`${name}-${tier}`) || `player-${tier.toLowerCase()}`;
    let candidate = base;
    let suffix = 2;
    while (usedIds.has(candidate)){
      candidate = `${base}-${suffix++}`;
    }
    usedIds.add(candidate);
    return { id:candidate, name, tier, hp, dps };
  }
  function buildFromSheets(statsMatrix, playersMatrix){
    tiers = {};
    TIER_ORDER.forEach(tier=> tiers[tier] = {hp:100, dps:5, players:[]});

    if (statsMatrix && statsMatrix.length){
      const start = findHeaderRow(statsMatrix);
      const headers = statsMatrix[start] || [];
      const cols = mapHeaderToTiers(headers);
      const hpRow = statsMatrix[start+1] || [];
      const dpsRow = statsMatrix[start+2] || [];
      cols.forEach((tierName, idx)=>{
        if (!tierName) return;
        const hp = parseFloat(hpRow[idx]);
        const dps = parseFloat(dpsRow[idx]);
        if (!Number.isNaN(hp)) tiers[tierName].hp = hp;
        if (!Number.isNaN(dps)) tiers[tierName].dps = dps;
      });
    }

    if (playersMatrix && playersMatrix.length){
      const start = findHeaderRow(playersMatrix);
      const headers = playersMatrix[start] || [];
      const cols = mapHeaderToTiers(headers);
      for (let r=start+1;r<playersMatrix.length;r++){
        const row = playersMatrix[r] || [];
        for (let c=0;c<row.length;c++){
          const tier = cols[c];
          if (!tier) continue;
          const name = (row[c]||'').trim();
          if (!name || tiers[tier].players.includes(name)) continue;
          tiers[tier].players.push(name);
        }
      }
    }

    players = [];
    const usedIds = new Set();
    for (const tier of TIER_ORDER){
      const baseHp = tiers[tier].hp;
      const baseDps = tiers[tier].dps;
      for (const name of tiers[tier].players){
        players.push(createPlayerRecord(name, tier, baseHp, baseDps, usedIds));
      }
    }
  }

  function buildFallbackData(){
    tiers = {};
    TIER_ORDER.forEach(tier=>{
      const fallback = FALLBACK_STATS.tiers[tier] || { hp: 100, dps: 5 };
      tiers[tier] = { hp: fallback.hp, dps: fallback.dps, players: [...(FALLBACK_PLAYERS[tier] || [])] };
    });
    players = [];
    const usedIds = new Set();
    for (const tier of TIER_ORDER){
      const { hp, dps } = tiers[tier];
      tiers[tier].players.forEach(name=>{
        players.push(createPlayerRecord(name, tier, hp, dps, usedIds));
      });
    }
  }

  // === RENDER ===
  function tierBadge(tier){
    const badge = el('span',{className:'badge tier'});
    badge.textContent = tier;
    badge.style.borderColor = TIER_COLORS[tier] || 'rgba(255,255,255,.2)';
    badge.style.color = TIER_COLORS[tier] || '#cbd5e1';
    badge.style.background = 'rgba(255,255,255,.05)';
    return badge;
  }
  function playerCard(player, mode){
    const card = el('div',{className:'card', id:`card-${player.id}`});
    const top = el('div',{className:'row'});
    top.append(el('div',{className:'name', textContent:player.name}), tierBadge(player.tier));
    const stats = el('div',{className:'row'});
    stats.append(
      el('div',{className:'stat', innerHTML:`HP <span class="v">${fmtNum(player.hp)}</span>`}),
      el('div',{className:'stat', innerHTML:`DPS <span class="v">${fmtNum(player.dps)}</span>`})
    );
    card.append(top, stats);
    if (mode==='team'){
      const hpRow = el('div',{className:'row'});
      const hpText = el('div',{className:'stat', id:`hptext-${player.id}`});
      hpText.innerHTML = `HP <span class="v">${fmtNum(hpMap[player.id] ?? player.hp)}</span>`;
      const bar = el('div',{className:'hpmini'});
      const fill = el('div',{id:`bar-${player.id}`});
      bar.append(fill);
      const status = el('div',{id:`status-${player.id}`, className:'badge', style:'opacity:.8'});
      hpRow.append(hpText, status);
      card.append(hpRow, bar);
    }
    return card;
  }
  function renderPlayers(){
    const wrap = $('#players');
    wrap.innerHTML='';
    if (!players.length){
      const empty = $('#playersEmpty');
      if (empty){
        empty.style.display='';
        empty.textContent = 'No players parsed. Ensure sheet headers include the tier names and that rows begin at row 2.';
      }
      return;
    }
    $('#playersEmpty').style.display='none';
    const grouped = Object.fromEntries(TIER_ORDER.map(t=>[t,[]]));
    players.forEach(p=> grouped[p.tier].push(p));
    for (const tier of TIER_ORDER){
      const list = grouped[tier];
      if (!list.length) continue;
      const header = el('div',{className:'card'});
      header.append(el('div',{className:'name', textContent:`${tier} · ${list.length}` }));
      wrap.append(header);
      list.forEach(player=> wrap.append(playerCard(player,'collection')));
    }
  }
  function updateTeamHPUI(){
    for (const id of teamIds){
      const player = players.find(p=> p.id===id);
      if (!player) continue;
      const currentHp = hpMap[id] ?? player.hp;
      const pct = clamp((currentHp/player.hp)*100,0,100);
      const bar = $(`#bar-${id}`);
      if (bar) bar.style.width = `${pct}%`;
      const hpText = $(`#hptext-${id}`);
      if (hpText) hpText.innerHTML = `HP <span class="v">${fmtNum(Math.max(0,currentHp))}</span>`;
      const status = $(`#status-${id}`);
      if (status) status.textContent = currentHp<=0 ? 'KO' : '';
    }
  }
  function renderTeam(){
    teamIds = [...collectionIds];
    const wrap = $('#team');
    wrap.innerHTML='';
    const team = teamIds.map(id=> players.find(p=> p.id===id)).filter(Boolean);
    if (!team.length){
      $('#teamEmpty').style.display='';
    } else {
      $('#teamEmpty').style.display='none';
      team.forEach(p=> wrap.append(playerCard(p,'team')));
    }
    updateTeamHPUI();
    const totalDps = team.reduce((sum,p)=> sum + p.dps,0);
    const totalHp = team.reduce((sum,p)=> sum + (hpMap[p.id] ?? p.hp),0);
    $('#yourDPS').textContent = fmtNum(totalDps);
    $('#yourHP').textContent = fmtNum(totalHp);
    updateRecruitCostUI();
  }

  // === COLLECTION ===
  function pruneCollection(){
    const available = new Set(players.map(p=> p.id));
    const seen = new Set();
    const filtered = [];
    let changed = false;
    for (const id of collectionIds){
      if (!available.has(id)){
        changed = true;
        continue;
      }
      if (seen.has(id)){
        changed = true;
        continue;
      }
      seen.add(id);
      filtered.push(id);
    }
    if (changed){
      collectionIds = filtered;
    }
    return changed;
  }
  function addToCollection(id){
    if (!collectionIds.includes(id)) collectionIds.push(id);
    pruneCollection();
    save();
    renderPlayers();
    renderTeam();
  }

  // === BOSS ===
  const BOSS_NAMES = ['Rust-Eaten Golem','Gelatinous Overmind','Cave Hydra','Skull Furnace','Storm Djinn','Ancient Treant','Hollow Colossus','Obsidian Wyrm','Clockwork Behemoth','Astral Leech'];
  function genBoss(level, teamDps=1, teamHp=1){
    const name = `${pick(BOSS_NAMES)}${level>=10?' [Ω]':''}`;
    const targetTTK = 18 + level*1.1;
    const difficulty = 1 + level*0.18;
    const variance = rand(0.9,1.1);
    const maxHp = Math.max(50, teamDps * targetTTK * difficulty * variance);
    const bossDps = Math.max(1, teamHp / (targetTTK*1.1)) * rand(0.9,1.1);
    return { name, level, maxHp:Math.round(maxHp), hp:Math.round(maxHp), dps:bossDps };
  }
  function rewardFor(level){
    const base = 0.12;
    const growth = 0.035 * level;
    const variance = rand(0.95,1.05);
    return Math.round((base + growth) * variance * 100)/100;
  }
  function renderBoss(){
    if (!boss) return;
    $('#bossName').textContent = boss.name;
    $('#bossLevel').textContent = boss.level;
    $('#bossBadge').textContent = `Level ${boss.level}`;
    $('#bossStats').textContent = `HP ${Math.ceil(boss.hp)} / ${boss.maxHp}`;
    $('#hpFill').style.width = `${clamp((boss.hp/boss.maxHp)*100,0,100)}%`;
  }
  function newBoss(){
    const team = teamIds.map(id=> players.find(p=> p.id===id)).filter(Boolean);
    hpMap = {};
    team.forEach(p=> hpMap[p.id] = p.hp);
    const dps = Math.max(1, team.reduce((sum,p)=> sum + p.dps,0));
    const totalHp = team.reduce((sum,p)=> sum + p.hp,0) || 100;
    boss = genBoss(bossLevel, dps, totalHp);
    save();
    renderBoss();
    renderTeam();
    $('#fightNote').textContent = 'A new foe appears!';
  }

  // === COMBAT ===
  function livingIds(){
    return teamIds.filter(id=> (hpMap[id] ?? 0) > 0);
  }
  function stopFight(){
    if (fightTimer) clearInterval(fightTimer);
    fightTimer = null;
    fighting = false;
    $('#fightBtn').disabled = false;
    $('#newBossBtn').disabled = false;
  }
  function startFight(){
    if (fighting || !boss) return;
    const team = teamIds.map(id=> players.find(p=> p.id===id)).filter(Boolean);
    const dps = team.reduce((sum,p)=> sum + p.dps,0);
    if (dps <= 0){
      alert('Your team has no DPS. Recruit at least one card.');
      return;
    }
    fighting = true;
    $('#fightBtn').disabled = true;
    $('#newBossBtn').disabled = true;
    const tickMs = 100;
    fightTimer = setInterval(()=>{
      boss.hp = Math.max(0, boss.hp - dps * (tickMs/1000));
      const alive = livingIds();
      if (alive.length){
        const target = pick(alive);
        const baseHp = players.find(p=> p.id===target)?.hp || 0;
        hpMap[target] = Math.max(0, (hpMap[target] ?? baseHp) - boss.dps*(tickMs/1000));
      }
      updateTeamHPUI();
      renderBoss();
      if (boss.hp <= 0){
        stopFight();
        const reward = rewardFor(boss.level);
        cash += reward;
        bossLevel += 1;
        save();
        $('#cash').textContent = fmtCash(cash);
        $('#fightNote').textContent = `Victory! You earned ${fmtCash(reward)}.`;
      } else if (!livingIds().length){
        stopFight();
        $('#fightNote').textContent = 'Defeat! All allies fell. Click New Boss to revive everyone.';
      }
    }, tickMs);
  }

  // === RECRUITING ===
  function recruit(){
    if (!players.length){
      alert('No players loaded yet.');
      return;
    }
    ensureDailyCounters();
    const cost = currentRecruitCost();
    if (cost>0 && cash < cost){
      alert(`Not enough cash. Roll costs ${fmtCash(cost)}.`);
      return;
    }
    const tier = pickTierWithPity();
    if (!tier){
      alert('You already own every available card!');
      return;
    }
    const candidates = players.filter(p=> p.tier===tier && !collectionIds.includes(p.id));
    if (!candidates.length){
      alert('No candidates available in that tier.');
      return;
    }
    const card = pick(candidates);
    if (cost>0){
      cash = Math.max(0, cash - cost);
      $('#cash').textContent = fmtCash(cash);
    }
    recruitsToday += 1;
    addToCollection(card.id);
    bumpPity(tier);
    save();
    updateRecruitCostUI();
    $('#fightNote').textContent = `Recruited ${card.name} (${tier}).`;
  }

  // === FREE COMMON ===
  function handleFreeCommon(){
    const commons = tiers['F-Tier']?.players || [];
    let candidate = commons.length ? pick(commons) : null;
    if (!candidate){
      const everyone = players.map(p=> p.name);
      if (!everyone.length){
        alert('No players available to grant yet.');
        return;
      }
      candidate = pick(everyone);
    }
    const card = players.find(p=> p.name===candidate && p.tier==='F-Tier') || players.find(p=> p.name===candidate);
    if (!card){
      alert('Could not find a card to grant.');
      return;
    }
    if (collectionIds.includes(card.id)){
      $('#fightNote').textContent = 'Common already owned.';
      return;
    }
    addToCollection(card.id);
    $('#fightNote').textContent = `Granted ${card.name}!`;
    $('#freeCardBtn').style.display = 'none';
  }

  // === BOOT ===
  async function boot(){
    load();
    $('#cash').textContent = fmtCash(cash);
    $('#bossLevel').textContent = bossLevel;
    $('#fightBtn').onclick = startFight;
    $('#newBossBtn').onclick = ()=>{ if (!fighting) newBoss(); };
    $('#freeCardBtn').onclick = handleFreeCommon;
    $('#recruitBtn').onclick = recruit;
    $('#resetBtn').onclick = ()=>{
      if (confirm('Reset local progress?')){
        localStorage.clear();
        location.reload();
      }
    };
    updateRecruitCostUI();
    let loadedFromSheets = false;
    try{
      const [playersCsv, statsCsv] = await Promise.all([
        fetch(SHEET_PLAYERS_URL).then(r=> r.text()),
        fetch(SHEET_STATS_URL).then(r=> r.text())
      ]);
      buildFromSheets(parseCSV(statsCsv), parseCSV(playersCsv));
      loadedFromSheets = players.length > 0;
      if (!loadedFromSheets){
        console.warn('Sheets loaded but no players parsed; falling back to bundled sample roster.');
      }
    } catch (err){
      console.error('Failed to load Google Sheets data:', err);
    }
    if (!players.length){
      buildFallbackData();
      const empty = $('#playersEmpty');
      if (empty){
        empty.style.display='';
        empty.textContent = loadedFromSheets
          ? 'Sheets parsed but no players found. Loaded sample roster instead.'
          : 'Using offline sample roster. Publish the linked sheets to replace this data.';
      }
    }
    renderPlayers();
    const pruned = pruneCollection();
    if (pruned) save();
    renderTeam();
    if (!boss) newBoss(); else renderBoss();
    if (!collectionIds.length) $('#freeCardBtn').style.display='';
    else $('#freeCardBtn').style.display='none';
  }
  boot();
  </script>
</body>
</html>
